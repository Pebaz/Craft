::->
Executables are created when a collection of code contains a global main
function. The collection of code is compiled as a library when no such function
exists in the codebase.

The opening and closing braces: '[' and ']' are how code is imported. By
keeping all module code in blocks, you can start using the block because it is
already in braces. Perhaps the compiler could generate blocks for you?

Notice how imports are placed before the program block. This makes it so that
imports are not given to the importer of this module. If that is the desired
behavior, just put them inside the block.

Imports add a new module block to the runtime's namespace list.

Although Craft takes care of all namespaces automatically based on folder
structure (like Python), you can explicitly set the package using the mod
keyword (perhaps pack/package).

Block comments are automatically assigned to function's __doc__ variable. Block
comments at the beginning of the file are given to the very first module
definition in the file.
<-::

import craft.io :: Do not share this import

:: The default access modifier just hides it from the above layer
str file_private_var = "I can only be seen by things in this file!"

mod colonist.EXAMPLE [ :: Program Entry Point

import colonist.game.utils :: Share this since it is very commonly used
from colonist.common import Time as tm :: Basically tm = colonist.common.Time

str(package) package_global_var = "Other modules in this same package can see me!"
str module_private_var = "I can only be seen by things in this module!"

::-> This is an interface. <-::
model IExplodable
[
	void(public) def explode()
]

:: Arbitrary code is allowed!
for int32 i in Range(10)
[
	print('This is precedural code, not object oriented!')
]

type Car improves Vehicle, WorldEntity models IExplodable
[
	int8(private) clrRed = 255
	int8(private) clrGreen = 155
	int8(private) clrBlue = 0
	str(private) plate :: nil is automatically assigned to vars without a value
	get_rand_type() rand_var = nil :: Types can be gotten from functions!!!

	Car(public) def new(int8 r, g, b, str plate)
	[
		me.clrRed = r; me.clrGreen = g; me.clrBlue = b
		me.plate = plate
	]

	int32(public) def get_color()
	[
		return (clrRed << 24) | (clrGree << 16) | (clrBlue << 8) | 255;
	]

	::->
	This is a small method.
	<-::
	str(public, static) def get_brand() return "Honda"

	::->
	This is another small method that is indented.
	<-::
	str(public, static) def get_brand2()
		return "Honda".allcaps()

	void(public, override) def explode()
	[
		for int32 i in Range(0, 10, 1)
		[
			print("BOOM!")
		]
	]

	void(public) def do_this()
	[
		while true
		[
			print(get_brand())
		]

		do
		[
			print(get_brand())
		]
		while true
	]

	@watch('this')
	void(public, override) def __addop__()
	[
		try
		[
			dangerous_op()
		]
		catch BilboException fff
		[
			print(fff.get_stack_trace())
		]
		finally
		[
			print('Done!')
		]
	]

	print('Midway through the class def!!!') :: Is this allowed?

	void(public) def bobby_jr()
	[
		with Dodim() as dd
		[
			:: Calls dd.__before__()
			print(dd)
			:: Calls dd.__after__()
		]
	]
]
] :: End Program



::->
This is a doc string that is attached to this module.
<-::
mod another.module.in.same.file [

type Bob
[
	Bob(public) new()
	[

	]
]

]





::->
Array-like class.

MAKE EVERYTHING HOMOICONIC:
 - DATA IS CODE
 - CODE IS DATA
 - (EVERYTHING GETS EVALUATED AS A FUNCTION OR A TYPE)
<-::

type(public) List <T>
[
	:: Since all variables are declared as const by default, declare as fluid
	fluid int(public) size
	fluid pointer(int, public) starting_address 

	::->
	Adds an element to the back of the collection.
	<-::
	void(public) def push(T in_back)
	[
		:: Add it to the end
	]

	T(public) def pop()
	[
		:: Remove and return the last element in the collection
	]

	void(public) unshift(T in_front)
	[
		:: Add an element to the front of the collection
	]

	T(public) def shift()
	[
		:: Remove and return the first element in the collection
	]
]